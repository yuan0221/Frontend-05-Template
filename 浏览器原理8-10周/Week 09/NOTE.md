# HTML解析
- ## 词法分析
  - ### HTML parse模块拆分
    - parser单独拆分到一个文件中
    - parser接受HTML文本作为参数，返回一颗DOM树
  - ### 用有限状态机（FSM）来实现HTML的分析
    - 在HTML标准中，已经规定了HTML的状态，80种
    - Toy-Browser，只挑选其中部分状态，完成最简版的一个浏览器
  - ### 解析标签
    - 标签类型 开始标签，结束标签，自封闭标签
    - 这一步暂时忽略属性 
  - ### 创建元素
    - 在状态机中，除了状态迁移，还会加入业务逻辑
    - 在标签开始时创建Token，进入tagName状态
    - 在html的tagName状态机中构建Token
    - 在标签结束状态提交标签token
  - ### 处理属性
    - 属性值分为单引号，双引号，无引号三种写法，因此需要较多的状态处理
    - 处理属性的方式和标签类似
    - 属性开始时，创建新的属性，进入attributeName状态
    - 在attributeName状态机中构建属性
    - 属性结束时候，把属性加到标签Token上
- ## 语法分析
  - ### 用token构建DOM树
    - 用栈构建DOM树，进行HTML的语法分析
    - 遇到开始标签时创建元素并入栈，遇到结束标签时出栈
    - 自封闭节点可以认为入栈后立即出栈
    - 任何元素的父元素是它入栈前的栈顶
  - ### 将文本节点加到DOM树
    - 文本节点与自封闭标签处理类似
    - 多个文本节点需要合并
 

# CSS计算
- ### 收集CSS规则
  - 使用npm的css包，相当于css parser的一个包，对css进行语法，词法分析，把css代码变成抽象语法树AST
  - 遇到style标签时，把css规则保存起来
  - 调用css parser分析css规则
  - 研究此库分析css规则的格式
- ### 添加调用
  - 当创建一个元素的后，立即计算css，看css规则是否匹配上了这个元素
  - 创建一个元素的意思是startTag入栈后,立即调用computeCSS
  - 本次步骤重要的是调用computeCSS的时机
  - 理论上，当我们分析一个元素时，假设css规则已经全部收集完毕
  - 真实浏览器中，可能遇到写在body的style标签，需要重新计算的情况，这里忽略 
- ### 获取父元素序列
  - 在computedCSS函数中，我们必须知道所有元素的父元素才能判断元素是否与规则匹配
  - 我们从上一步的stack，可以获取本元素的所有父元素
  - 因为我们首先获取的是当前元素，所以我们获得和计算父元素匹配的顺序是由内向外
  - div div #myId {}
- ### 处理选择器与元素的匹配
  - 选择器也要从当前元素向外排列
  - 复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列
- ### 计算选择器与元素是否匹配
  - 根据选择器的类型和元素属性，计算当前的元素是否匹配
  - 这里只实现了三种基本的选择器，实际浏览器要处理复合选择器
- ### 生成computed属性
  - 一旦选择匹配，就应用选择器到元素上，形成computedStyle
- ### specificity的计算
  - css规则根据 specificity 特征，专一性，和后来优先规则覆盖
  - specificity是个四元组，越左边权重越重 
    - [0,    0,   0,    0]
    - inline id  class tag
  - 一个css规则的specificity根据包含的简单选择器相加而成