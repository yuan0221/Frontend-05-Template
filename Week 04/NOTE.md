## 字符串分析算法
- 字典树
  - 大量高重复字符串的存储与分析
- KMP
  - 解决的问题是在一个字符串中找到是否包含搜索的字符串
  - 举例在字符串`‘aabaaadxxx’`中搜索`'aabaaac'`
    - 关注自重复
      - 匹配值：理解就是字符串的头部和尾部的重合部分的长度
      
      搜索值|a|a|b|a|a|a|c
      --|:--:|--:|--:|--:|--:|--:|--:|
      匹配值|0|1|0|1|2|2|0 

  - 参考阮一峰的[字符串匹配的KMP算法](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)

- Wildcard
  - 带通配符的字符串模式
- 正则
  - 字符串通用模式匹配
- 状态机
  - 通用的字符串分析
- LL LR
  - 字符串多层级结构分析

## 正则表达式（补充知识）
- 元字符
  - .匹配除过换行外任意单个字符
  - \d 任意单个数字
  - \w 任意单个字母数字下划线
  - \s 任意单个空白符
  - \D \W \S 都是对应的取反
  - 可以用 \s\S \d\D \w\W 表示真正的任意单个字符，表示字符的全集

- 贪婪模式，非贪婪模式，独占模式
  - 贪婪模式
    - 量词默认是贪婪模式
  - 非贪婪模式
    - 量词后面加 ? 表示非贪婪模式
  - 独占模式
    - 量词后面加 + 表示独占模式
    - 不同语言的支持度需要调查

- 分组(子组)，编号
  - 分组
    - 保存分组 （正则）
    - 不保存分组 （?:正则）
    - 分组引用，js中使用$1,...
  - 编号
    - 多括号嵌套，编号从左到右
    - 编号不容易维护时，出现命名分组，命名分组的语言支持度待调查

- 4种匹配模式
  - 不区分大小写模式
    - 使用模式修饰符(?i)
  - 点号通配模式
    - 使用模式修饰符(?s)
    - 改变的是点号的匹配行为，让.可以匹配任何字符，包括换行
    - js中不支持，用 \s\S \d\D \w\W  替代
  - 多行模式
    - 使用模式修饰符(?m)
    - 多行匹配说的是 ^ 和 $ 的匹配行为，让其可以匹配上每行的开头或结尾。
  - 注释模式
    - (?#comment) 

- 断言
  - 单词边界 \b
  - 行的开始或结束 ^ $
  - 环视
    - 分类
      - 肯定逆向 (?<=Y) 左边是Y
      - 否定逆向 (?<!Y) 左边不是Y
      - 肯定顺序 (?=Y)  右边是Y
      - 否定顺序 (?!=Y) 右边不是Y
    - 记忆口诀：左尖括号代表看左边，没有尖括号是看右边，感叹号是非的意思。
    - 由于环视只是匹配文本位置，不匹配内容，所以圆括号不进行分组与编号
    - 环视可以理解为检测左右的环境

- 转义
  - 功能
    - 转编码无法用字母表直接表示的特殊数据
    - 用于表示无法直接键盘录入的字符（如回车符）
  - 符号
    - \r 回车
    - \n 换行
    - \t 水平制表
    - \v 垂直制表
    - \\ 表示\
    - \' 表示'
    - \" 表示"

- 流派
  - 正则起源的线索可追溯到20世纪40年代的神经系统研究
  - 到了80年代，出现首个正则的规范，到了90年代又出现一个规范，因此形成两个流派

- 正则要解决的问题
  - 校验文本内容
    - js中使用^和$表示每行的开头和结尾，默认情况下匹配整个文本的开头和和结尾（默认不是多行匹配模式） 
    - 使用多行匹配模式，会改变^和$的行为
    - js中的使用例子：
    ``` 
      方法一：
      /^\d{4}-\d{2}-\d{2}$/.test('2020-12-28');  //true
      
      方法二：
      const re = /^\d{4}-\d{2}-\d{2}$/;
      '2020-12-28'.search(re) === 0      //true

      方法三：
      const re = new RegExp(/^\d{4}-\d{2}-\d{2}$/);
      re.test('2020-12-28');   //true

      RegExp在全局模式下连续调用
      const re = new RegExp(/^\d{4}-\d{2}-\d{2}$/, 'g');
      re.test('2020-12-28');   //true
      re.lastIndex  //10
      re.test('2020-12-28');   //false
      re.lastIndex  //0
      re.test('2020-12-28');   //true
      re.lastIndex  //10
      re.test('2020-12-28');   //false
      re.lastIndex  //0
      ...
      连续调用结果是true和false交替出现，原因是：RegExp在全局模式下，匹配到一个后，会记下lastIndex，每次查找从lastIndex处开始查找，如果查找不到，
      则lastIndex变为0，从0处开始

      es6中新加匹配模式u,含义为“Unicode模式”,用来处理4个字节的UTF-16编码
    ```
  - 提取文本内容
    - js中要提取文本的内容，必须使用g模式
    - 使用例子：
      ```
        使用g模式，查找符合要求的内容
        "2020-11 2020-12".match(/\d{4}-\d{2}/g);  // ["2020-11", "2020-12"]

        不使用g模式，找到第一个就会停下来
        "2020-11 2020-12".match(/\d{4}-\d{2}/);  // ["2020-11", index: 0, input: "2020-11 2020-12", groups: undefined]
      ```
  - 替换文本内容
    - 使用例子：
      ```
        使用g模式，替换所有的
        '12-28-2020 12-27-2020'.replace(/(\d{2})-(\d{2})-(\d{4})/g, "$3年$1月$2日");   //"2020年12月28日 2020年12月27日"

        不使用g模式，只替换一次
        '12-28-2020 12-27-2020'.replace(/(\d{2})-(\d{2})-(\d{4})/, "$3年$1月$2日");   //"2020年12月28日 12-27-2020"
      ```
  - 切割文本内容
    - 使用例子：
      ```
        "apple, pear! orange; tea".split(/\W+/);  // ["apple", "pear", "orange", "tea"]
      ```




