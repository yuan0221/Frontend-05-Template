<script>
  // 斐波拉契数列 ☆
  function fib(n) {
    if (n < 2)
      return n;

    let n1 = 0,
      n2 = 1,
      sum = 0;
    for (let i = 0; i < n - 1; i++) {
      sum = (n1 + n2) % 1000000007;
      n1 = n2;
      n2 = sum;
    }
    return sum;
  }

  const fib2 = function (n) {
    if (n < 2)
      return n;

    let num1 = 0,
      num2 = 1,
      sum = 0;
    while (n >= 2) {
      sum = (num1 + num2) % 1000000007;
      num1 = num2;
      num2 = sum;
      n--;
    }
    return sum;
  };

  // 反转字符串 ☆
  function reverse(arr) {
    let i = arr.length - 1;
    while (i > 0) {
      arr.splice(arr.length - i - 1, 0, arr.pop());
      i--;
    }
    return arr;
  }

  function reverse2(arr) {
    let i = arr.length - 1;
    while (i >= arr.length / 2) {
      const temp = arr[i];
      arr[i] = arr[arr.length - i - 1];
      arr[arr.length - i - 1] = temp;
      i--;
    }
    return arr;
  }

  // 反转一句话中的每个单词 ☆
  function reverseWords(s) {
    function reverse(item) {
      return item.split('').reverse().join('');
    }
    let arr = s.split(/\s+/);
    arr = arr.map(item => reverse(item));
    return arr.join(' ');
  }

  function reverseWords2(s) {
    function format(match) {
      return match.split('').reverse().join('');
    }
    return s.replace(/\S+/g, format);
  }

  // 给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。
  // 如果剩余字符少于 k 个，则将剩余字符全部反转。
  // 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。
  // 示例：
  // 输入: s = "abcdefg", k = 2
  // 输出: "bacdfeg"
  function reverseStr(s, k) {
    return s.match(new RegExp(`(\\w){${2 * k}}|(\\w){1,${2 * k - 1}}`, 'g'))
      .map(str => str.slice(0, k).split('').reverse().join('') + str.slice(k))
      .join('');
  }

  
</script>